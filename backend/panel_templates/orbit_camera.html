<!DOCTYPE html>
<html>
<head>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #18181b; overflow: hidden; width: 100%; height: 100vh; }
  canvas { width: 100%; height: 100%; cursor: grab; touch-action: none; }
  canvas:active { cursor: grabbing; }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
const CONFIG = {};

// --- Defaults ---
const posUniforms = CONFIG.posUniforms || ["u_cam_pos_x", "u_cam_pos_y", "u_cam_pos_z"];
const targetUniforms = CONFIG.targetUniforms || ["u_cam_target_x", "u_cam_target_y", "u_cam_target_z"];
const initPos = CONFIG.initialPosition || [2, 1.5, 2];
const initTarget = CONFIG.initialTarget || [0, 0, 0];

// --- Quaternion helpers ---
function normalizeQ(q) {
  var len = Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]+q[3]*q[3]);
  return len < 1e-12 ? [1,0,0,0] : [q[0]/len,q[1]/len,q[2]/len,q[3]/len];
}
function mulQ(a, b) {
  return normalizeQ([
    a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3],
    a[0]*b[1]+a[1]*b[0]+a[2]*b[3]-a[3]*b[2],
    a[0]*b[2]-a[1]*b[3]+a[2]*b[0]+a[3]*b[1],
    a[0]*b[3]+a[1]*b[2]-a[2]*b[1]+a[3]*b[0]
  ]);
}
function rotV(q, v) {
  var w=q[0],x=q[1],y=q[2],z=q[3], vx=v[0],vy=v[1],vz=v[2];
  var tx=2*(y*vz-z*vy), ty=2*(z*vx-x*vz), tz=2*(x*vy-y*vx);
  return [vx+w*tx+y*tz-z*ty, vy+w*ty+z*tx-x*tz, vz+w*tz+x*ty-y*tx];
}
function quatFromVecs(from, to) {
  var dot = from[0]*to[0]+from[1]*to[1]+from[2]*to[2];
  if (dot > 0.999999) return [1,0,0,0];
  if (dot < -0.999999) {
    var axis = Math.abs(from[0]) > 0.9 ? [0,1,0] : [1,0,0];
    var cx=from[1]*axis[2]-from[2]*axis[1], cy=from[2]*axis[0]-from[0]*axis[2], cz=from[0]*axis[1]-from[1]*axis[0];
    var len=Math.sqrt(cx*cx+cy*cy+cz*cz);
    return normalizeQ([0,cx/len,cy/len,cz/len]);
  }
  var cx=from[1]*to[2]-from[2]*to[1], cy=from[2]*to[0]-from[0]*to[2], cz=from[0]*to[1]-from[1]*to[0];
  return normalizeQ([1+dot,cx,cy,cz]);
}
function screenToSphere(cx, cy, rect) {
  var nx=((cx-rect.left)/rect.width)*2-1, ny=-(((cy-rect.top)/rect.height)*2-1);
  var r2=nx*nx+ny*ny;
  if (r2 <= 1) return [nx, ny, Math.sqrt(1-r2)];
  var len=Math.sqrt(r2);
  return [nx/len, ny/len, 0];
}

// --- State ---
var dir = [initPos[0]-initTarget[0], initPos[1]-initTarget[1], initPos[2]-initTarget[2]];
var dLen = Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]);
if (dLen < 1e-12) dLen = 1;
var norm = [dir[0]/dLen, dir[1]/dLen, dir[2]/dLen];

var quat = quatFromVecs(norm, [0,0,1]);
var dist = dLen;
var target = [initTarget[0], initTarget[1], initTarget[2]];
var initDist = dist;
var initTargetCopy = [target[0], target[1], target[2]];

var dragging = false, panning = false;
var lastSphere = null, lastPointer = null;

// --- Push uniforms ---
function pushUniforms() {
  var inv = [quat[0], -quat[1], -quat[2], -quat[3]];
  var d = rotV(inv, [0,0,1]);
  var camPos = [target[0]+d[0]*dist, target[1]+d[1]*dist, target[2]+d[2]*dist];
  panel.setUniform(posUniforms[0], camPos[0]);
  panel.setUniform(posUniforms[1], camPos[1]);
  panel.setUniform(posUniforms[2], camPos[2]);
  panel.setUniform(targetUniforms[0], target[0]);
  panel.setUniform(targetUniforms[1], target[1]);
  panel.setUniform(targetUniforms[2], target[2]);
}

// --- Camera direction helpers ---
function getCamVectors() {
  var inv = [quat[0], -quat[1], -quat[2], -quat[3]];
  var camDir = rotV(inv, [0,0,1]);
  var fx=-camDir[0], fy=-camDir[1], fz=-camDir[2];
  var rLen = Math.sqrt(fz*fz+fx*fx);
  var right = rLen > 1e-6 ? [-fz/rLen, 0, fx/rLen] : [1,0,0];
  var up = [right[1]*fz-right[2]*fy, right[2]*fx-right[0]*fz, right[0]*fy-right[1]*fx];
  return { right: right, up: up, camDir: camDir };
}

// --- Render wireframe cube ---
function render() {
  var cv = document.getElementById("cv");
  var ctx = cv.getContext("2d");
  var dpr = window.devicePixelRatio || 1;
  var w = cv.clientWidth, h = cv.clientHeight;
  cv.width = w * dpr; cv.height = h * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, w, h);

  var zoom = Math.min(3, Math.max(0.2, initDist / dist));
  var s = Math.min(w, h) * 0.32 * zoom;

  var inv = [quat[0], -quat[1], -quat[2], -quat[3]];
  var camDir = rotV(inv, [0,0,1]);
  var fx=-camDir[0], fy=-camDir[1], fz=-camDir[2];
  var rLen = Math.sqrt(fz*fz+fx*fx);
  var right3d = rLen > 1e-6 ? [-fz/rLen, 0, fx/rLen] : [1,0,0];
  var up3d = [right3d[1]*fz-right3d[2]*fy, right3d[2]*fx-right3d[0]*fz, right3d[0]*fy-right3d[1]*fx];

  var dt = [target[0]-initTargetCopy[0], target[1]-initTargetCopy[1], target[2]-initTargetCopy[2]];
  var pixPerUnit = Math.min(w, h) * 0.15;
  var panX = -(dt[0]*right3d[0]+dt[1]*right3d[1]+dt[2]*right3d[2]) * pixPerUnit * zoom;
  var panY = (dt[0]*up3d[0]+dt[1]*up3d[1]+dt[2]*up3d[2]) * pixPerUnit * zoom;

  var cx = w/2 + panX, cy = h/2 + panY;

  var verts = [[-1,-1,-1],[1,-1,-1],[1,1,-1],[-1,1,-1],[-1,-1,1],[1,-1,1],[1,1,1],[-1,1,1]];
  var edges = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]];
  var axes = [{dir:[1.4,0,0],color:"rgba(239,68,68,"},{dir:[0,1.4,0],color:"rgba(34,197,94,"},{dir:[0,0,1.4],color:"rgba(59,130,246,"}];

  function project(v) { var r=rotV(quat,v); return [cx+r[0]*s, cy-r[1]*s, r[2]]; }
  var proj = verts.map(project);

  edges.forEach(function(e) {
    var pa=proj[e[0]], pb=proj[e[1]];
    var avgZ = (pa[2]+pb[2])/2;
    var alpha = 0.25 + 0.55*((avgZ+1)/2);
    ctx.strokeStyle = "rgba(161,161,170,"+alpha.toFixed(2)+")";
    ctx.lineWidth = 1.2;
    ctx.beginPath(); ctx.moveTo(pa[0],pa[1]); ctx.lineTo(pb[0],pb[1]); ctx.stroke();
  });

  var origin = project([0,0,0]);
  axes.forEach(function(a) {
    var tip = project(a.dir);
    var alpha = 0.4 + 0.5*((tip[2]+1)/2);
    ctx.strokeStyle = a.color+alpha.toFixed(2)+")";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(origin[0],origin[1]); ctx.lineTo(tip[0],tip[1]); ctx.stroke();
    ctx.fillStyle = a.color+Math.min(1,alpha+0.2).toFixed(2)+")";
    ctx.beginPath(); ctx.arc(tip[0],tip[1],2.5,0,Math.PI*2); ctx.fill();
  });
}

// --- Event handlers ---
var cv = document.getElementById("cv");

cv.addEventListener("pointerdown", function(e) {
  e.preventDefault();
  dragging = true;
  panning = e.altKey;
  cv.setPointerCapture(e.pointerId);
  if (e.altKey) {
    lastPointer = [e.clientX, e.clientY];
  } else {
    lastSphere = screenToSphere(e.clientX, e.clientY, cv.getBoundingClientRect());
  }
});

cv.addEventListener("pointermove", function(e) {
  if (!dragging) return;
  if (panning) {
    if (!lastPointer) return;
    var dx = e.clientX - lastPointer[0], dy = e.clientY - lastPointer[1];
    lastPointer = [e.clientX, e.clientY];
    var v = getCamVectors();
    var panSpeed = dist * 0.004;
    target[0] -= dx*panSpeed*v.right[0] + dy*panSpeed*v.up[0];
    target[1] -= dx*panSpeed*v.right[1] + dy*panSpeed*v.up[1];
    target[2] -= dx*panSpeed*v.right[2] + dy*panSpeed*v.up[2];
  } else {
    var rect = cv.getBoundingClientRect();
    var cur = screenToSphere(e.clientX, e.clientY, rect);
    if (!lastSphere) return;
    var delta = quatFromVecs(lastSphere, cur);
    quat = mulQ(delta, quat);
    lastSphere = cur;
  }
  render();
  pushUniforms();
});

cv.addEventListener("pointerup", function() {
  dragging = false; panning = false;
  lastSphere = null; lastPointer = null;
});

cv.addEventListener("wheel", function(e) {
  e.preventDefault();
  e.stopPropagation();
  if (e.ctrlKey) {
    var factor = 1 + e.deltaY * 0.01;
    dist = Math.max(0.1, dist * factor);
  } else {
    var v = getCamVectors();
    var panSpeed = dist * 0.003;
    target[0] -= e.deltaX*panSpeed*v.right[0] - e.deltaY*panSpeed*v.up[0];
    target[1] -= e.deltaX*panSpeed*v.right[1] - e.deltaY*panSpeed*v.up[1];
    target[2] -= e.deltaX*panSpeed*v.right[2] - e.deltaY*panSpeed*v.up[2];
  }
  render();
  pushUniforms();
}, { passive: false });

cv.addEventListener("dblclick", function() {
  quat = quatFromVecs(norm, [0,0,1]);
  dist = initDist;
  target = [initTargetCopy[0], initTargetCopy[1], initTargetCopy[2]];
  render();
  pushUniforms();
});

// --- Init ---
render();
pushUniforms();

// Sync from external uniform changes
panel.onUpdate = function() { render(); };
</script>
</body>
</html>
